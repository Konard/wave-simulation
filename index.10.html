<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Tiny Maxwell 1-D FDTD — periodic ring, two pulses, baseline-locked</title>
<!--
────────────────────────────────────────────────────────────────────────────
PROBLEM WE FIX NOW
────────────────────────────────────────────────────────────────────────────
Even with a *zero-area* (bipolar) source, numerical round-off makes the
spatial average of E_z drift by ~10⁻⁷ per step.  Over tens of thousands of
laps that DC error becomes visible: the dotted baseline splits into two.

PHYSICAL NOTE  
A *constant* offset of E_z in a periodic domain carries **no energy** and
does not enter Maxwell’s curl equations (spatial derivatives kill it).  
So it is perfectly legal to subtract the mean <E_z> (and <H_y>) every step;
doing so is called **DC blocking** and does *not* alter the propagating
waves we care about — it only keeps the plotted baseline pinned to 0.

CHANGES  
• After each FDTD step we compute ⟨E_z⟩ and ⟨H_y⟩ and subtract them.  
  That clamps the baseline forever, eliminating the late-time split.  
• Everything else (two counter-propagating pulses, interference spike,
  pause/resume behaviour, full documentation) is unchanged.

References  
• Maxwell     https://en.wikipedia.org/wiki/Maxwell%27s_equations  
• Yee lattice https://en.wikipedia.org/wiki/Yee_lattice  
• FDTD        https://en.wikipedia.org/wiki/Finite-difference_time-domain_method  
────────────────────────────────────────────────────────────────────────────
-->
<style>
html,body{
  margin:0;height:100%;
  display:flex;justify-content:center;align-items:center;
  background:#101010;color:#ddd;font:14px/1 monospace;
}
canvas{image-rendering:pixelated;box-shadow:0 0 8px #000}
#ui   {position:fixed;bottom:1em;left:1em;opacity:.8}
</style>
</head>
<body>
<canvas id="wave-canvas"></canvas>
<div id="ui">SPACE = pause / resume</div>

<script>
/* ════════════════════════════════════════════════════════════════════════
 * SECTION 1 — Numerical constants
 * ════════════════════════════════════════════════════════════════════ */
const CELLS            = 600;   // Yee cells around the ring
const DX               = 1;     // spatial step
const COURANT          = 1;     // cΔt = Δx (no numerical dispersion)
const DT               = DX / COURANT;
const DRAW_SCALE       = 0.7;   // vertical scale factor (cosmetic)
const RUN_FOREVER      = Number.POSITIVE_INFINITY;

/* ════════════════════════════════════════════════════════════════════════
 * SECTION 2 — Field arrays
 * ════════════════════════════════════════════════════════════════════ */
const Ez = new Float32Array(CELLS); // electric field   E_z(i)
const Hy = new Float32Array(CELLS); // magnetic field   H_y(i+½)

/* ════════════════════════════════════════════════════════════════════════
 * SECTION 3 — Canvas set-up
 * ════════════════════════════════════════════════════════════════════ */
const canvas = document.getElementById('wave-canvas');
canvas.width  = CELLS;   // one pixel per Yee cell
canvas.height = 200;
const ctx  = canvas.getContext('2d');
const img  = ctx.createImageData(canvas.width, canvas.height);

function drawEz () {
  const mid = canvas.height / 2;
  for (let x = 0; x < CELLS; ++x) {
    const yPix = Math.round(mid - Ez[x] * DRAW_SCALE * mid);
    for (let y = 0; y < canvas.height; ++y) {
      const p = (y * CELLS + x) * 4;
      const on = y === yPix;
      img.data[p+0] = on ? 255 :  32;
      img.data[p+1] = on ? 128 :  32;
      img.data[p+2] = on ? 128 :  32;
      img.data[p+3] = 255;
    }
  }
  ctx.putImageData(img, 0, 0);
}

/* ════════════════════════════════════════════════════════════════════════
 * SECTION 4 — Bipolar (zero-area) Gaussian source
 * ════════════════════════════════════════════════════════════════════ */
const SRC      = Math.floor(CELLS / 2);
const PEAK_T   = 30;  // tick of peak
const WIDTH_T  =  8;  // σ

function bipolarGaussian (t) {
  const τ = (t - PEAK_T) / WIDTH_T;
  return -τ * Math.exp(-0.5 * τ * τ); // derivative of Gaussian
}

/* ════════════════════════════════════════════════════════════════════════
 * SECTION 5 — One FDTD step + DC blocking
 * ════════════════════════════════════════════════════════════════════ */
function stepFDTD (t) {

  /* 5.1 — update H_y at n+½ */
  for (let i = 0; i < CELLS; ++i) {
    const ip1 = (i + 1) % CELLS;
    Hy[i] += (Ez[ip1] - Ez[i]) * DT / DX;
  }

  /* 5.2 — inject additive bipolar pulse (spawns two travelling waves) */
  const pulse = bipolarGaussian(t);
  Hy[(SRC - 1 + CELLS) % CELLS] -= 0.5 * pulse;
  Ez[SRC]                        +=       pulse;

  /* 5.3 — update E_z at n+1 */
  for (let i = 0; i < CELLS; ++i) {
    const im1 = (i - 1 + CELLS) % CELLS;
    Ez[i] += (Hy[i] - Hy[im1]) * DT / DX;
  }

  /* 5.4 — DC blocking: remove tiny floating-point drift in <E_z> & <H_y> */
  let sumE = 0, sumH = 0;
  for (let i = 0; i < CELLS; ++i) { sumE += Ez[i]; sumH += Hy[i]; }
  const meanE = sumE / CELLS;
  const meanH = sumH / CELLS;
  for (let i = 0; i < CELLS; ++i) { Ez[i] -= meanE; Hy[i] -= meanH; }
}

/* ════════════════════════════════════════════════════════════════════════
 * SECTION 6 — Animation loop with pause / resume
 * ════════════════════════════════════════════════════════════════════ */
let tick = 0;
let running = true;

function frame () {
  if (!running) return;
  if (tick < RUN_FOREVER) {
    stepFDTD(tick);
    drawEz();
    ++tick;
    requestAnimationFrame(frame);
  }
}
requestAnimationFrame(frame);

window.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    running = !running;
    if (running) requestAnimationFrame(frame);
  }
});
</script>
</body>
</html>